\documentclass[a4paper, 11pt]{article}

% ====== PACCHETTI NECESSARI ======
\usepackage[utf8]{inputenc}
\usepackage[italian]{babel}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage[table]{xcolor}
\usepackage{colortbl}
\usepackage{tabularx}
\usepackage{array}
\usepackage{amssymb}
\usepackage{fancyhdr}
\usepackage{titlesec}
\usepackage{helvet}
\renewcommand{\familydefault}{\sfdefault}
\usepackage{lipsum}
\usepackage{hyperref}
\usepackage{booktabs}
\usepackage{enumitem}

% ====== IMPOSTAZIONI GLOBALI DI STILE ======

% 1. DEFINIZIONE COLORI BLU-VIOLA
\definecolor{AccentColor}{RGB}{80, 90, 180}
\definecolor{AccentLight}{RGB}{120, 130, 210}
\definecolor{AccentDark}{RGB}{50, 60, 140}
\definecolor{LightGray}{RGB}{245, 245, 250}
\definecolor{MediumGray}{RGB}{200, 200, 210}

% 2. IMPOSTAZIONE MARGINI
\geometry{a4paper, left=2.5cm, right=2.5cm, top=3.5cm, bottom=3.5cm}
\setlength{\headheight}{14pt}

% 3. STILE DEI TITOLI DI SEZIONE
\titleformat{\section}
  {\normalfont\sffamily\Large\bfseries\color{AccentColor}}
  {\thesection}{1em}{}

\titleformat{\subsection}
  {\normalfont\sffamily\large\bfseries\color{AccentDark}}
  {}{0em}{}

% 4. IMPOSTAZIONE HEADER E FOOTER
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\sffamily\bfseries\color{AccentColor}BYTE HOLDERS}
\fancyhead[R]{\sffamily\color{AccentColor}\thepage}
\renewcommand{\headrulewidth}{0.8pt}
\renewcommand{\headrule}{\color{AccentColor}\hrule width\headwidth height\headrulewidth \vskip-\headrulewidth}

% 5. IMPOSTAZIONE LINK
\hypersetup{
    colorlinks=true,
    linkcolor=AccentColor,
    urlcolor=AccentLight,
    citecolor=AccentDark,
}

% 6. PERSONALIZZAZIONE ELENCHI
\setlist[itemize]{itemsep=2pt, topsep=4pt}
\setlist[enumerate]{itemsep=2pt, topsep=4pt}

% ====== COMANDI PERSONALIZZATI ======
\makeatletter
\newcommand{\NomeGruppo}[1]{\def\@NomeGruppo{#1}}
\newcommand{\TitoloVerbale}[1]{\def\@TitoloVerbale{#1}}
\newcommand{\Sommario}[1]{\def\@Sommario{#1}}
\newcommand{\Autore}[1]{\def\@Autore{#1}}
\newcommand{\Verificatore}[1]{\def\@Verificatore{#1}}
\makeatother

% ====== STILE TABELLE MIGLIORATO ======
\newcolumntype{Y}{>{\raggedright\arraybackslash}X}
\setlength{\arrayrulewidth}{0.4pt}
\setlength{\tabcolsep}{10pt}
\renewcommand{\arraystretch}{1.4}

\newcommand{\GlossarioLettera}[1]{%
    \clearpage
    \begin{center}
        {\LARGE \sffamily \color{AccentColor}\bfseries #1}
    \end{center}
    %\section*{#1}
    \addcontentsline{toc}{section}{#1}
    \textcolor{AccentColor}{\rule{\textwidth}{0.4pt}}
}
\newcommand{\nocontentsline}[3]{}
\newcommand{\term}[1]{\vspace*{.5cm}\bgroup\let\addcontentsline=\nocontentsline\subsection{#1}\label{term:#1}\egroup}
\newcommand{\refterm}[1]{\nameref{term:#1}}

% ====== INIZIO DEL DOCUMENTO ======
\begin{document}

\NomeGruppo{BYTE HOLDERS}
\TitoloVerbale{Glossario}
\Sommario{Documento che riporta la definizione dei termini usati durante lo svolgimento del progetto}
\Autore{}
\Verificatore{}

\pagestyle{empty}

% ====== PAGINA DI TITOLO ======
\begin{titlepage}
    \centering
    
    \includegraphics[width=0.55\textwidth]{../Assets/ByteHolders1.png}\par\vspace{1.5cm}
    
    {\LARGE \sffamily \color{AccentColor}\bfseries Glossario}\par
    \vspace{0.5cm}
    

\end{titlepage}

\pagestyle{fancy}
\newpage
\tableofcontents
\newpage


% ====== SEZIONE PRINCIPALE ======
\GlossarioLettera{A}
\term{Agente}
Un agente è un'entità autonoma in grado di: ragionare, pianificare, interagire con API e strumenti esterni, modificando l'ambiente esterno in cui opera per raggiungere obiettivi specifici.\\
I principali componenti di un agente sono:
\begin{itemize}
    \item \textbf{Model}: modello generativo (es. \refterm{LLM}) usato dall'agente. La sua efficacia dipende dalla qualità e quantità dei dati su cui è stato addestrato.\\
     Diversamente dal modello puro, l'agente può ampliare le proprie capacità tramite interazioni con strumenti esterni.
    \item \textbf{Reasoning Loop}: processo iterativo di pensiero e decisione dell'agente., in cui distingue i passaggi necessari e decide quali azioni eseguire.\\
    Può essere implementato con framework come ReAct.
    \item \textbf{Tools}: strumenti esterni con cui l'agente interagisce con l'ambiente esterno per ottenere informazioni o eseguire azioni. Vedi \refterm{Tool}.
\end{itemize}

\term{Amazon Web Services}

\term{Ambiente}
Vedi \refterm{Variabili d'Ambiente}

\term{Analisi dei Requisiti}

\term{API}
Un'API (Application Programming Interface) è un insieme di regole e protocolli che consente a diverse applicazioni software di comunicare tra loro. È un'interfaccia per accedere a funzionalità o dati specifici di un'applicazione, servizio o piattaforma, facilitando l'integrazione e l'interoperabilità tra sistemi diversi.

\term{API Token}
Chiave unica talvolta necessaria per accedere a una \refterm{API}.

\term{AWS}

\GlossarioLettera{B}
\term{Bedrock}
\term{Board}
Una Board è una bacheca in stile Kanban che permette di monitorare lo stato di avanzamento del progetto, attraverso l'organizzazione visuale delle attività (issue) da svolgere (Backlog, se non è ancora da prendere in carico - Ready, quando la issue è pronta per essere svolta), in corso (In Progress), in revisione (in Review, in attesa di verifica e approvazione) e terminate (Done).

\term{Branch}
Un branch (ramo) è una linea di sviluppo indipendente (una copia separata del codice sorgente) all'interno di un sistema di controllo versione (VCS), come Git. Permette agli sviluppatori di lavorare su funzionalità, correzioni di bug o esperimenti senza influenzare direttamente il ramo principale.

\GlossarioLettera{C}
\term{Chain-of-thought prompting}

\term{Cognito}

\term{Container}
Processo isolato per le componenti di un'applicazione. Un container è:
\begin{itemize}
	\item autocontenuto, nel senso che non si appoggia su dipendenze della macchina su cui corre
	\item isolato, garantendo maggiore sicurezza per le applicazioni. A differenza di una macchina virtuale la separazione non avviene a livello kernel.
	\item gestito indipendentemente dagli altri container
	\item portatile, nel senso che lo stesso container può correre allo stesso modo su macchine diverse
\end{itemize}

 Si ottiene eseguendo una \refterm{Immagine (Docker)} tramite \refterm{Docker}.

\term{Context Prompt}

\term{CVE}

\term{CVSS}

\term{CWE}

\GlossarioLettera{D}
\term{Database non relazionale}

\term{Database relazionale}

\term{Database vettoriale}

\term{Dev}
Vedi \refterm{Developer}.

\term{Developer}
Il Developer è la figura responsabile di progettare, scrivere, testare e mantenere il codice necessario a realizzare le funzionalità di un progetto software. Traduce i requisiti forniti da Project Manager e Tech Lead in soluzioni tecniche concrete, contribuendo allo sviluppo, all'evoluzione e alla qualità del prodotto.

Le sue principali responsabilità sono:
\begin{itemize}
  \item \textbf{Sviluppo del codice}: implementa nuove funzionalità, corregge bug e realizza le componenti software richieste.
  \item  \textbf{Collaborazione tecnica}: interagisce con Tech Lead e altri sviluppatori per garantire coerenza e qualità.
  \item \textbf{Test e qualità}: scrive test, verifica il funzionamento del proprio codice e contribuisce alla stabilità del sistema.
  \item \textbf{Documentazione}: documenta funzionalità, API, processi e soluzioni implementate.
  \item \textbf{Manutenzione}: aggiorna, ottimizza e riorganizza il codice esistente quando necessario.
\end{itemize}

\term{Docker}
Piattaforma per sviluppare e condividere applicazioni in modo che siano separate dalla loro infrastruttura (vedi \refterm{Container}). Facilita la riproducibilità della costruzione di software nonché il loro sviluppo e la scalabilità.

Utilizza un'architettura client-server, dove il demone \texttt{dockerd} (locale o remoto) e il client (ad es. \refterm{docker compose}) comunicano tramite \refterm{API} \refterm{REST} tramite socket o rete.

\term{docker compose}
Comando che permette di eseguire \refterm{Container} multipli secondo una configurazione specificata in un file \refterm{YAML}, permettendo la configurazione ad esempio di reti, volumi e variabili d'ambiente.

\term{Dockerfile}
File contenente le istruzioni per la costruzione di un'\refterm{Immagine (Docker)}. A seguire istruzioni comuni\footnote{\url{https://docs.docker.com/reference/dockerfile}}:
\begin{itemize}
	\item \texttt{FROM}: definisce l'immagine di partenza
	\item \texttt{WORKDIR}: definisce la \textit{working directory} all'interno del filesystem dummy dell'immagine
	\item \texttt{COPY <host-path> <image-path>}: copia tutti i file/directory presenti a \texttt{<host-path>} (dell'utente) in \texttt{<wd>/<image-path>} (dell'immagine). Qui, \texttt{<wd>} è definita dal comando \texttt{WORKDIR}
	\item \texttt{RUN <cmd>}: esegue \texttt{<cmd>} da riga di comando. Si noti che
	\begin{enumerate}
		\item la cache non viene invalidata in build successive, salvo l'esecuzione di \texttt{docker build --no-cache} in fase di build
		\item dal momento che \texttt{RUN} genera un nuovo layer, effettuare un'operazione che influenza(ad esempio) solamente la shell corrente non influenzerà i comandi successivi. Ad esempio, se entro attivo un \texttt{virtualenv} di python con un comando \texttt{RUN}, e successivamente eseguo \texttt{RUN pip install...}, il pacchetto non verrà installato all'interno dell'ambiente virtuale.
	\end{enumerate}
	\item \texttt{ENV <name> <value>}: assegna \texttt{<name>=<value>} a livello di \refterm{Ambiente}
	\item \texttt{EXPOSE <port>}: indica la porta che vorresti esporre. In realtà è solo documentativa: il comando in sé non espone la porta, ma lo comunica a chi eseguirà poi il container. Starà a quella persona poi pubblicare la porta ad esempio utilizzando la flag \texttt{-p} in \texttt{docker run -p<host>:<container>/<protocol>}. In tal caso, il comando specifica che avviene port-forwarding dalla porta \texttt{<host>} dell'host a quella \texttt{<container>} del container, utilizzando protocollo \texttt{<protocol>} che può essere \texttt{udp} o \texttt{tcp}.
	\item \texttt{USER <user/uuid>}: specifica l'utente per le istruzioni successive
	\item \texttt{CMD ["<command>", "<arg1>"]}: specifica il comando che il container eseguirà ogni volta che viene fatto correre. Ce ne può essere solamente uno per container e deve essere l'ultima istruzione presente nel file.
\end{itemize}

\term{Documentazione}
\GlossarioLettera{E}

\GlossarioLettera{F}
\term{Few-shot prompting}

\term{FM}

\term{Foundation Model}

\term{Framework}

\GlossarioLettera{G}
\term{Git}
Git è un sistema di controllo versione distribuito che consente di tracciare le modifiche apportate ai file e coordinare il lavoro tra più sviluppatori.\\
I principali comandi di git sono:
\begin{itemize}
    \item \textbf{git clone $<$url$>$}: Clona un repository remoto in locale.
    \item \textbf{git add $<$file$>$}: Aggiunge file specifici all'area di staging.
    \item \textbf{git add .}: Aggiunge tutti i file modificati all'area di staging.
    \item \textbf{git rm $<$file$>$}: Rimuove file specifici dal repository e dall'area di staging
    \item \textbf{git commit -m "messaggio"}: Crea un commit con i file nell'area di staging e un messaggio descrittivo.
    \item \textbf{git push origin $<$branch$>$}: Invia i commit locali al repository remoto sul branch specificato.
    \item \textbf{git pull origin $<$branch$>$}: Recupera e integra le modifiche dal repository remoto al branch locale.
    \item \textbf{git status}: Mostra lo stato dei file nel repository, inclusi quelli modificati, aggiunti o non tracciati.
    \item \textbf{git diff}: Mostra le differenze tra i file modificati e l'ultima versione committata.
    \item \textbf{git branch}: Elenca, crea o elimina branch nel repository.
    \item \textbf{git checkout $<$branch$>$}: Passa a un branch specifico.
    \item \textbf{git switch $<$branch$>$}: Alternativa a git checkout per cambiare branch.
    \item \textbf{git fetch}: Recupera gli aggiornamenti dal repository remoto senza integrarli automaticamente.
    \item \textbf{git merge $<$branch$>$}: Unisce un branch specifico nel branch corrente.
    \item \textbf{git rebase $<$branch$>$}: Integra le modifiche di un branch specifico riscrivendo la cronologia dei commit.
\end{itemize}

\term{GitHub}
GitHub è una piattaforma di hosting per lo sviluppo software e il versionamento basato su Git che permette di:
\begin{itemize}
    \item collaborare allo sviluppo di software in modo distribuito,
    \item gestire issue, pull request, documentazione
    \item automatizzare processi tramite GitHub Actions
\end{itemize}
È ampiamente utilizzata per progetti open-source e collaborativi.

\term{Gitflow}
Gitflow è un workflow per Git basato su branch multipli con ruoli specifici. Permette una chiara separazione tra sviluppo, rilascio e manutenzione.\\
La struttura principale include:
\begin{itemize}
    \item \textbf{master}:contiene solo versioni pronte al rilascio
    \item \textbf{develop}: rappresenta lo stato corrente dello sviluppo
    \item \textbf{feature branches}: uno per ogni nuova funzionalità
    \item \textbf{release branches}: preparazione della versione
    \item \textbf{hotfix branches}: correzioni urgenti sul master
\end{itemize}
I principali comandi di gitflow sono:
\begin{itemize}
  \item \textbf{git flow init}: Inizializza un repository Gitflow.
  \item \textbf{git flow feature start $<$nome-feature$>$}: Crea e passa a un nuovo branch di funzionalità.
  \item \textbf{git flow feature finish $<$nome-feature$>$}: Unisce il branch di funzionalità nel branch develop e lo elimina.
  \item \textbf{git flow feature publish $<$nome-feature$>$}: Pubblica il branch di funzionalità sul repository remoto.
  \item \textbf{git flow feature pull origin $<$nome-feature$>$}: Recupera e integra le modifiche dal branch di funzionalità remoto.
  \item \textbf{git flow feature track $<$nome-feature$>$}: Crea un branch di funzionalità locale che traccia il branch remoto.
  \item \textbf{git flow release start release $[$BASE$]$ $<$versione$>$}: Crea un nuovo branch di release a partire dal branch specificato (di default develop).
  \item \textbf{git flow feature release publish $<$versione$>$}: Pubblica il branch di release sul repository remoto.
  \item \textbf{git flow release finish $<$versione$>$}: Unisce il branch di release nei branch master e develop, crea un tag per la versione e elimina il branch di release.
  \item \textbf{git flow hotfix start $<$nome-hotfix$>$ $[$BASE$]$}: Crea un nuovo branch di hotfix a partire dal branch specificato (di default master).
  \item \textbf{git flow hotfix finish $<$nome-hotfix$>$}: Unisce il branch di hotfix nei branch master e develop, crea un tag per la versione e elimina il branch di hotfix.
\end{itemize}

\term{GitHub Actions}
GitHub Actions è il sistema di automazione di GitHub che consente di eseguire workflow automatizzati direttamente all'interno del repository. Permette di creare processi personalizzati per la compilazione, il test, il rilascio e la distribuzione del codice, nonché per altre attività legate allo sviluppo software, in risposta ad eventi del repository, come push o pull request.

\term{GitHub Linguist}

\GlossarioLettera{H}
\term{Human Prompt}

\GlossarioLettera{I}
\term{IaaS}

\term{IAM}

\term{Identity and Access Management}

\term{Immagine (Docker)}
Un pacchetto in sola lettura che contiene tutti i file, le librerie e le configurazioni per eseguire un \refterm{Container}. Un'immagine è composta da vari strati (\textit{layer}) che rappresentano le modifiche applicate a un'immagine di partenza. La composizioni in strati permette una costruzione di container più rapida e il risparmio di spazio, dal momento che sono condivisibili.

Immagini docker possono essere trovate su \url{https://hub.docker.com/}.

\term{Infrastructure as a Service}

\term{Issue}
Un’issue è uno strumento di GitHub utilizzato per segnalare bug, proporre nuove funzionalità, discutere idee o tracciare attività.

\GlossarioLettera{J}
\term{JavaScript}

\term{JSON}

\GlossarioLettera{K}

\GlossarioLettera{L}
\term{Langchain}

\term{Langgraph}

\term{Large Language Model}

\term{LaTeX}
LaTeX Linguaggio di marcatura (mark-down) compilato per la realizzazione di documenti.

\term{Linguist}

\term{LLM}

\GlossarioLettera{M}
\term{Milestone}
Una milestone è un contenitore che raggruppa issue e pull request sotto un obiettivo comune, di solito legato a una versione, uno sprint o una fase del progetto.\\
Permette di:
\begin{itemize}
    \item monitorare i progressi verso obiettivi specifici (percentuale di completamento),
    \item organizzare le attività verso una scadenza condivisa,
    \item facilitare la pianificazione e la comunicazione all'interno del team.
\end{itemize}

\term{MongoDB}

\term{MongoDB Atlas}

\GlossarioLettera{N}
\term{NestJS}

\term{NodeJS}

\term{NoSQL}

\term{Norme di Progetto}

\term{npm}

\term{NVD}

\GlossarioLettera{O}
\term{One-shot prompting}

\term{Orchestratore Autocratico} %RIGUARDARE
L'orchestratore è il componente centrale di un sistema ad agenti che coordina e gestisce le operazioni degli agenti per raggiungere obiettivi specifici in modo efficiente.\\
In un sistema ad agenti con orchestratore autocratico, l'orchestratore prende decisioni centralizzate e dirige le azioni degli agenti senza consultare o coinvolgere gli agenti stessi nel processo decisionale. In questo sistema gli agenti svolgono compiti molto specifici.\\

\term{OWASP Top 10}

\GlossarioLettera{P}
\term{PaaS}

\term{Platform as a Service}

\term{Project Manager}
Il Project Manager (PM) è la figura responsabile della gestione completa del ciclo di vita di uno o più progetti, garantendone la realizzazione nel rispetto di tempi, costi, qualità e obiettivi stabiliti. Pur non essendo necessariamente un esperto tecnico di sviluppo software, coordina persone, attività e risorse, fungendo da punto di contatto tra team di sviluppo, organizzazione e cliente.\\
Le sue principali responsabilità sono:
\begin{itemize}
  \item \textbf{Gestione del Progetto}: Definire obiettivi, scope, tempistiche e budget del progetto, assicurando che vengano rispettati durante tutto il ciclo di vita del progetto
  \item \textbf{Pianificazione e Organizzazione}: Definisce il piano di progetto, stabilisce scadenze, milestones e priorità operative.
  \item \textbf{Comunicazione con il Cliente}: Raccoglie requisiti, chiarisce aspettative, condivide stato avanzamento e gestisce richieste o modifiche.
  \item \textbf{Assegnazione delle Risorse/Assegnazioni (chi fa cosa)}: Decide a quali Developer assegnare i vari progetti di cui è responsabile.
  \item \textbf{Monitoraggio dell'Avanzamento}: Controlla lo stato dei lavori, interviene in caso di rischi o ritardi, assicura il rispetto degli standard.
  \item \textbf{Qualità e Conformità}: Definisce standard e requisiti per documentazione e deliverable.
\end{itemize}

\term{Piano di Progetto}

\term{Piano di Qualifica}

\term{PMD}

\term{PoC}

\term{Proof of Concept}

\GlossarioLettera{Q}
\term{Query}

\GlossarioLettera{R}
\term{Raccolta}

\term{React}

\term{Report}

\term{REST}

\term{Role Prompt}

\GlossarioLettera{S}
\term{SaaS}

\term{Sarif}

\term{Schema}

\term{semgrep}

\term{Serverless}

\term{Sistema ad agenti}
Un sistema ad agenti è un insieme di entità autonome, chiamate agenti, che interagiscono tra loro per raggiungere obiettivi specifici all'interno di un ambiente condiviso. Ogni agente possiede capacità di percezione, decisione e azione, permettendo loro di adattarsi e collaborare in modo dinamico.

\term{Software as a Service}

\term{SonarQube}

\term{Sprint}
Uno sprint è una piccola porzione di tempo (due settimane nel nostro caso) durante il quale un team porta a termine una determinata quantità di lavoro. Gli sprint prevedono
\begin{itemize}
	\item una riunione iniziale, per pianificare gli obbiettivi e lo svolgimento dello sprint
	\item check-in giornalieri, per controllare l'andamento dello sprint e reagire tempestivamente a eventuali problematiche
	\item una riunione retrospettiva al termine dello sprint, per pianificare e migliorare gli sprint futuri
\end{itemize}

\term{Swagger}

\term{System Prompt}

\GlossarioLettera{T}
\term{Tag}

\term{Tag raccolta}

\term{Tech Lead}
Un tech lead (o technical lead) è il supervisore tecnico di più progetti. È la figura che unisce visione tecnica e capacità di coordinamento, fungendo da ponte tra il Project Manager e il team di sviluppo.\\
Garantisce la solidità dell'architettura, la qualità del codice e la corretta applicazione delle tecnologie, supportando il team nella risoluzione dei problemi più complessi.\\
Le sue principali responsabilità sono:
\begin{itemize}
  \item \textbf{Supporto e Mentoring}: fornire supporto tecnico al team di sviluppo e al Project Manager, aiutando a risolvere problemi complessi e guidando le decisioni tecniche riguardo alle tecnologie di cui si occupa.
  \item \textbf{Standard Tecnici}:  Assicurare che il codice e le pratiche di sviluppo rispettino gli standard di qualità (guarda i risultati dei test e il test coverage, per valutare la qualità complessiva del codice prodotto), sicurezza (identifica le vulnerabilità o criticità del prodotto) e performance definiti. Mantiene aggiornate librerie e dipendenze e monitora i rischi legati alle tecnologie adottate.
  \item \textbf{Architettura e Design}: Revisionare e approvare le decisioni architetturali, contribuendo alla definizione della direzione tecnica dei progetti.
  \item \textbf{Monitoraggio Aggregato}: Analizza dati provenienti da più repository e progetti (test results, test coverage, stato di sicurezza, indicatori di qualità) per identificare trend, criticità e colli di bottiglia.
\end{itemize}

\term{Test coverage}

\term{Tool}
Un tool è uno strumento esterno che estende le capacità di un \refterm{Agente}, permettendo ad esempio l'esecuzione di codice e recuperare informazioni aggiornate\footnote{\url{https://docs.langchain.com/oss/python/langchain/tools}}.

I tool si dividono in:
\begin{itemize}
	\item \textbf{Extensions}: collegano l'\refterm{Agente} a \refterm{API} esterne in modo autonomo, definendo quando, come e cosa aspettarsi dalla risposta.
	\item \textbf{Function calling}: usata quando l'\refterm{API} è “segreta”; guida gli input, ma la chiamata vera la fa un sistema esterno.
	\item \textbf{Data store / \refterm{Database vettoriale}}: permette all'agente di cercare informazioni in database, documenti o siti.
\end{itemize}
\term{Trivy}

\term{TypeScript}

\GlossarioLettera{U}

\GlossarioLettera{V}
\term{Variabili d'Ambiente}
Un insieme di variabili di sistema (\texttt{NAME=VALUE}) che un processo può leggere, modificando il proprio comportamento. Una variabile d'ambiente nota è \texttt{PATH}, che fa riferimento a una lista di cartelle contenenti file eseguibili (che quindi possono essere eseguiti per nome da riga di comando). Nel nostro caso, tramite \refterm{Docker} si possono indicare dei file che andranno a definire l'ambiente di un container. In questo modo si può facilmente (utilizzando la libreria \texttt{dotenv}) evitare di scrivere dei segreti all'interno di file che saranno caricati e condivisi pubblicamente. Mai condividere un \texttt{.env} file.

\term{VCS}
Un Version Control System (VCS) è un sistema software che gestisce e traccia tutte le modifiche effettuate a un insieme di file, come documenti, programmi o siti web. Ogni modifica viene registrata come una revisione identificata da un numero o codice, accompagnata da timestamp e autore.\\
Un VCS permette di confrontare versioni, ripristinare stati precedenti, condividere cambiamenti tra più utenti e gestire attività collaborative tramite funzionalità come branching, merging e tracciamento delle modifiche.

\GlossarioLettera{W}
\term{Workflow}
Il workflow è il processo o modello che stabilisce come vengono gestite le modifiche nello sviluppo del codice all'interno di un'organizzazione o di un progetto.\\
Ogni workflow definisce come si creano i branch, come si integrano le modifiche e come si collabora.\\
Il tipo di workflow dipende dal VCS utilizzato e dalle esigenze del team di sviluppo.
\term{Way of Working}
\GlossarioLettera{X}

\GlossarioLettera{Y}
\term{YAML}

\GlossarioLettera{Z}
\term{Zero-short prompting}

\end{document}